import json
import networkx as nx
from collections import defaultdict
import shutil
import os
from gemd.util.impl import recursive_foreach
import matplotlib.pyplot as plt
from matplotlib.lines import Line2D
import matplotlib.colors as colors
import matplotlib.cm as cmx
import matplotlib.patches as mpatches

_encoder = None
_subdirpath = None


def out(item):
    '''
    function object to run on individual item during recursion 
    :param item: json item to write its destination 
    '''
    fn = '_'.join([item.__class__.__name__, item.name, item.uids['auto']])
    with open(os.path.join(_subdirpath, fn),'w') as fp :
        fp.write(_encoder.thin_dumps(item,indent=3))

def plot_graph(dirpath, mode='run'):
    '''
    creates a NetworkX graph representation of the GEMD relationships by reading every object
    generated by the GEMDEncoder object, storing all of its links by uid, and forming directed relationships, 
    such as ingredient->process, or process->material
    It then allows filtering the objects mapped (i.e., removing spec or runs, 
    measurements or ingredients) and saves a NetworkX graph in "dot" as .png
    
    :param dirpath: source of graph 
    :param mode: to plot a graph of specs, runs or templates
    '''
    G = nx.DiGraph()
    mapping = defaultdict()
    nb_disregarded = 0
    gemd_objects = [os.path.join(dirpath, f) for f in os.listdir(dirpath)]
    for obj in gemd_objects:
        fp =  open(obj, 'r')
        obj_data = json.load(fp)
        obj_type = obj_data['type']
        if obj_type.startswith('parameter') or obj_type.startswith('condition') or obj_type.startswith('property'):
            nb_disregarded +=1
            continue
        uid = obj_data['uids']['auto']
        name = obj_data['name']
        mapping[uid] = name
        if obj_type.startswith('process'):
            if obj_type.endswith(mode):
                G.add_node(uid, color='red')
        elif obj_type.startswith('ingredient'): # if node doesn't exist, create?
            if obj_type.endswith(mode):
                G.add_node(uid, color='blue')
                # print(obj_data)
                _encoder.thin_dumps(obj_data, indent=3)
                process = obj_data['process']['id']
                material = obj_data['material']['id']
                G.add_edge(uid, process)
                G.add_edge(material, uid)
        elif obj_type.startswith('material'):
            if obj_type.endswith(mode):
                if obj_data['process']:
                    process = obj_data['process']['id']
                G.add_node(uid, color='green')
                G.add_edge(process, uid)
        elif obj_type.startswith('measurement'):
            if obj_type.endswith(mode):
                print("found measurement!")
                material = obj_data['material']['id']
                G.add_node(uid, color='purple')
                G.add_edge(uid, material)
         
    # legend_elements = [
    #     Line2D([0], [0], marker='o', color='w', label='Label1',markerfacecolor='g', markersize=15),
    #     Line2D([0], [0], marker='o', color='w', label='label2',markerfacecolor='r', markersize=15),        
    # ]
    # ColorLegend = {'Process': 'red','Ingredient': 'blue', 'Material': 'green','Measurement': 'purple'}
    # fig, ax = plt.subplots()
    # f = plt.figure(1)
    # ax = f.add_subplot(1,1,1)
    # values = []
    # for node in G.nodes():
    #     print(node)
    #     print(type(node))
    #     values.append(node.color)
    # print(values)
    # jet = cm = plt.get_cmap('jet')
    # cNorm  = colors.Normalize(vmin=0, vmax=max(values))
    # scalarMap = cmx.ScalarMappable(norm=cNorm, cmap=jet)
    # for label in ColorLegend:
    #     ax.plot([0],[0],color=scalarMap.to_rgba(ColorLegend[label]),label=label)
    # plt.legend()
    
    red_patch = mpatches.Patch(color='red', label='The red data')
    blue_patch = mpatches.Patch(color='blue', label='The blue data')
        
    G_bis = nx.nx_agraph.to_agraph(G)
    # print(type(G_bis))
    G_bis.layout(prog="dot")
    uid_path = os.path.join(dirpath, '{}_uid_graph.png'.format(mode))
    # legend_elements = [Line2D([0], [0], marker='o', color='blue', label='Female', lw=0,
                        #   markerfacecolor='blue', markersize=10),
                #    Line2D([0], [0], marker='o', color='orange', label='Male', lw=0,
                        #   markerfacecolor='orange', markersize=10)]
    # ax = plt.gca()
    # ax.legend(handles=legend_elements, loc='upper right')
    # plt.show()
    plt.legend(handles=[red_patch, blue_patch])
    G_bis.draw(uid_path)
    plt.close()
    
    # fig, ax = plt.subplot()
    relabeled_G = nx.relabel_nodes(G, mapping)
    G_bis = nx.nx_agraph.to_agraph(relabeled_G)
    G_bis.layout(prog="dot")
    info_path = os.path.join(dirpath, '{}_name_graph.png'.format(mode))
    plt.legend(handles=[red_patch, blue_patch])
    G_bis.draw(info_path)
    plt.close()
    
    
    print("cycles in the graph: {}".format(list(nx.simple_cycles(G))))
    print("nb of disregarded elements (i.e., templates/specs): {}/{}".format(nb_disregarded, len(gemd_objects)))
    return uid_path, info_path

def analyze(encoder, subdirpath, terminal_gemd_obj, mode):
    '''
    runs a series of tests on a set of GEMD objects. It starts by writing them to 
    subdirpath using a recursive function on the terminal gemd object in your worklow, 
    and custom plots a graph of GEMD objects.
    :param encoder: GEMDencoder object of the current run
    :param subdirpath: destination directory of your GEMD objects tied to a run
    :param terminal_gemd_obj: last gemd object in the pipeline/workflow 
    :param mode: determins what object type to plot
    '''
    # delete if it already exists
    if os.path.exists(subdirpath):
        shutil.rmtree(subdirpath)
    os.mkdir(subdirpath)
    global _subdirpath
    _subdirpath = subdirpath
    global _encoder
    _encoder = encoder
    if mode == "run":
        terminal_gemd_obj_entity = terminal_gemd_obj._run
    else:
        terminal_gemd_obj_entity = terminal_gemd_obj._spec
        
    encoder.thin_dumps(terminal_gemd_obj_entity,indent=3) # this step needs to be run to instantiate
    recursive_foreach(terminal_gemd_obj_entity, out)
    return plot_graph(subdirpath, mode=mode)