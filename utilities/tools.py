import json
import networkx as nx
from collections import defaultdict
import shutil
import os
from gemd.util.impl import recursive_foreach
import matplotlib.pyplot as plt
from matplotlib.lines import Line2D
import matplotlib.colors as colors
import matplotlib.cm as cmx
import matplotlib.patches as mpatches
from matplotlib import pylab


# _encoder = None
# _subdirpath = None


def out(item):
    """
    function object to run on individual item during recursion
    :param item: json item to write its destination
    """
    fn = "_".join([item.__class__.__name__, item.name, item.uids["auto"]])
    with open(os.path.join(_subdirpath, fn), "w") as fp:
        fp.write(_encoder.thin_dumps(item, indent=3))

def handle_gemd_obj(G, uid, obj_data, obj_type, mode):
    if obj_type.startswith("process"):
            if obj_type.endswith(mode):
                G.add_node(uid, color="red")
    elif obj_type.startswith("ingredient"):  # if node doesn't exist, create?
        if obj_type.endswith(mode):
            G.add_node(uid, color="blue")
            process = obj_data["process"]["id"]
            if obj_data["material"]:
                material = obj_data["material"]["id"]
            G.add_edge(uid, process)
            G.add_edge(material, uid)
    elif obj_type.startswith("material"):
        if obj_type.endswith(mode):
            G.add_node(uid, color="green")
            if obj_data["process"]:
                process = obj_data["process"]["id"]
                G.add_edge(process, uid)  # ?
    elif obj_type.startswith("measurement"):
        if obj_type.endswith(mode):
            G.add_node(uid, color="purple")
            if "material" in obj_data:
                material = obj_data["material"]["id"]
                G.add_edge(uid, material)
    

def save_graph(graph, file_name):
    
    
    #initialze Figure
    plt.figure(num=None, figsize=(20, 20), dpi=80)
    plt.axis('off')
    fig = plt.figure(1)
    pos = nx.spring_layout(graph)
    nx.draw_networkx_nodes(graph,pos)
    nx.draw_networkx_edges(graph,pos)
    nx.draw_networkx_labels(graph,pos)

    cut = 1.00
    xmax = cut * max(xx for xx, yy in pos.values())
    ymax = cut * max(yy for xx, yy in pos.values())
    plt.xlim(0, xmax)
    plt.ylim(0, ymax)

    plt.savefig(file_name,bbox_inches="tight")
    pylab.close()
    del fig
    
    
def plot_graph(dirpath, mode="run"):
    """
    creates a NetworkX graph representation of the GEMD relationships by reading every object
    generated by the GEMDEncoder object, storing all of its links by uid, and forming directed relationships,
    such as ingredient->process, or process->material
    It then allows filtering the objects mapped (i.e., removing spec or runs,
    measurements or ingredients) and saves a NetworkX graph in "dot" as .png

    :param dirpath: source of graph
    :param mode: to plot a graph of specs, runs or templates
    """
    G = nx.DiGraph()
    mapping = defaultdict()
    nb_disregarded = 0
    gemd_objects = [
        os.path.join(dp, f)
        for dp, dn, filenames in os.walk(dirpath)
        for f in filenames
        if not f.endswith(".png")
    ]
    if len(gemd_objects)==0:
        return

    for obj in gemd_objects:
        if "raw_jsons" in obj:
            continue
        fp = open(obj, "r")
        obj_data = json.load(fp)
        obj_type = obj_data["type"]
        if (
            obj_type.startswith("parameter")
            or obj_type.startswith("condition")
            or obj_type.startswith("property")
        ):
            nb_disregarded += 1
            continue
        uid = obj_data["uids"]["auto"]
        name = obj_data["name"]
        mapping[uid] = "{},  {}".format(name, uid[:3])
        handle_gemd_obj(G, uid, obj_data, obj_type, mode)

    # name
    _relabeled_G = nx.relabel_nodes(G, mapping)
    relabeled_G = nx.nx_agraph.to_agraph(_relabeled_G)
    relabeled_G.layout(prog="dot")
    relabeled_G.draw(os.path.join(dirpath, "{}_name_graph.svg".format(mode)))
    plt.close()
    # save_graph(G, info_path)
    
    with open(os.path.join(dirpath, "{}_name_graph.dot".format(mode)), 'x') as f:
        f.write(str(relabeled_G))

    print("cycles in the graph: {}".format(list(nx.simple_cycles(G))))
    print(
        "nb of disregarded elements (i.e., templates/specs): {}/{}".format(
            nb_disregarded, len(gemd_objects)
        )
    )


# def analyze(encoder, subdirpath, terminal_gemd_obj, mode):
#     '''
#     runs a series of tests on a set of GEMD objects. It starts by writing them to
#     subdirpath using a recursive function on the terminal gemd object in your worklow,
#     and custom plots a graph of GEMD objects.
#     :param encoder: GEMDencoder object of the current run
#     :param subdirpath: destination directory of your GEMD objects tied to a run
#     :param terminal_gemd_obj: last gemd object in the pipeline/workflow
#     :param mode: determins what object type to plot
#     '''
#     # delete if it already exists
#     if os.path.exists(subdirpath):
#         shutil.rmtree(subdirpath)
#     os.mkdir(subdirpath)
#     global _subdirpath
#     _subdirpath = subdirpath
#     global _encoder
#     _encoder = encoder
#     if mode == "run":
#         terminal_gemd_obj_entity = terminal_gemd_obj._run
#     else:
#         terminal_gemd_obj_entity = terminal_gemd_obj._spec

#     encoder.thin_dumps(terminal_gemd_obj_entity,indent=3) # this step needs to be run to instantiate
#     recursive_foreach(terminal_gemd_obj_entity, out)
#     return plot_graph(subdirpath, mode=mode)
